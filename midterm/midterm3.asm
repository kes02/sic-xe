	JSUB	QUEINIT
RDINT	LDA	ZERO	.총 몇개 숫자가 입력되는가
	TD	INPUT
	JEQ	RDINT
	RD	INPUT
	COMP	SPACE
	JEQ	RDRST
	SUB	#48
	STA	INT	.총 몇개의 숫자가 입력될지 
	J	RDINT
RDRST	LDA	ZERO	.되야하는 결과값 입력받음
	TD	INPUT
	JEQ	RDRST
	RD	INPUT
	COMP	ASEN
	JEQ	RSTREC	.0부터 count하기 위해 -> CNT+1이 입력받는 수 일 것
	STCH	BUFFER, X
	TIX	#5
	JLT	RDRST
	JEQ	RSTREC
RSTREC	STX	R_LAST
	STX	LEN
	LDX	ZERO
RSTSAVE	LDCH	BUFFER, X
	JSUB	RDIFF
	J	RARITH
RDIFF	COMP	#45	.첫 번쨰가 '-'인지 구분->양수면 맨 앞에 +를 넣어줌
	JEQ	RMINUS	.첫 번째가 -이면 미리 넣어둠
	JGT	RPLUS	.숫자이면 
RMINUS	STX	R_X
	LDA	ZERO
	LDCH	#45	.'-'의 아스키코드
	STCH	R_SIGN
	LDA	LEN	.증감을 하지 않는 이유 : 만약 -포함해서 4글자였을때 TIX 5일 경우에만 buffer,4까지 읽는데 줄이면 3까지만 읽음
	SUB	#1
	STA	LEN
	STA	R_LEN
	LDA	R_X
	ADD	#1
	STA	R_X
	RSUB	
RPLUS	STX	R_X
	LDA	ZERO
	LDCH	#43	.'+'의 아스키코드
	STCH	R_SIGN
	LDA	LEN
	STA	R_LEN
	RSUB
RARITH	LDA	ZERO
	STA	SUM	.전체 합한 값 초기화
	JSUB	RPARE	
	J	RDREC_I
RPARE 	LDX	G
	LDA	R_LEN
	COMP	#3	.|100~999| -> 100같이 0이 연속으로 들어갈 경우 씹히는 것 같아서 일의 자리와 십의 자리가 0이고 백의 자리가 0이 아니라면 백의 자리 * 100 해서 넣어야할 것 같음
	JEQ	RLOOP3
	COMP	#2	.|10~99|
	JEQ	RLOOP2
	JLT	RLOOP1	.1의 자리
RLOOP3	LDX	R_X	.100의 자릿수까지
	LDA	ZERO
	LDCH	BUFFER, X
	SUB	#48
	MUL	HUNDRED
	ADD	SUM
	STA	SUM
	TIX	LEN
	LDA	ZERO
	LDCH	BUFFER, X
	SUB	#48
	MUL	TEN
	ADD	SUM
	STA	SUM
	TIX	R_LAST
	LDA	ZERO
	LDCH	BUFFER,X
	SUB	#48
	ADD	SUM
	STA	RESULT
	RSUB
RLOOP2	LDX	R_X	.10의 자릿수인경우
	LDA	ZERO
	LDCH	BUFFER, X
	SUB	#48
	MUL	TEN
	ADD	SUM
	STA	SUM
	TIX	R_LAST
	LDA	ZERO
	LDCH	BUFFER,X
	SUB	#48
	ADD	SUM
	STA	RESULT
	RSUB
RLOOP1	LDX	R_X	.1의 자리인 경우
	LDA	ZERO
	LDCH	BUFFER,X
	SUB	#48
	ADD	SUM
	STA	RESULT
	RSUB

RDREC_I	+JSUB	CLEAN	.INT개의 숫자를 입력받음
	LDA	ZERO
	LDX	ZERO
RDINTLP	
	TD	INPUT
	JEQ	RDINTLP
	RD	INPUT
	COMP	SPACE	.해당 숫자 저장하러 가기
	JEQ	SAVEREC
	COMP	ASEN
	JEQ	SAVEREC	.SAVE랑 동작은 똑같지만 자릿수에 따라 더해주는 곳으로 감
	STCH	BUFFER, X
	TIX	#5
	JLT	RDINTLP
	JEQ	SAVEREC

SAVEREC	STX	B_LAST	.버퍼의 맨 끝
	STX	LEN		.RD한 것을 저장
	LDX	ZERO
SAVE	LDCH	BUFFER, X
	JSUB	DIFF	.부호를 넣어둠
	J	ARITH
	
DIFF	COMP	#45	.첫 번쨰가 '-'인지 구분->양수면 맨 앞에 +를 넣어줌
	JEQ	MINUS	.첫 번째가 -이면 미리 넣어둠
	JGT	PLUS	.숫자이면 
MINUS	STX	BUFF_X
	LDX	CNT
	LDCH	#45	.'-'의 아스키코드
	STCH	SIGN, X 
	STX	TMP
	LDA	LEN	.증감을 하지 않는 이유 : 만약 -포함해서 4글자였을때 TIX 5일 경우에만 buffer,4까지 읽는데 줄이면 3까지만 읽음
	SUB	#1
	STA	LEN
	STCH	STRLEN, X
	LDA	TMP
	ADD	#1
	STA	CNT
	LDA	BUFF_X
	ADD	#1
	STA	BUFF_X
	RSUB	
PLUS	STX	BUFF_X
	LDX	CNT
	LDCH	#43	.'+'의 아스키코드
	STCH	SIGN, X
	STX	TMP
	LDA	LEN
	STCH	STRLEN, X
	LDA	TMP
	ADD	#1
	STA	CNT
	RSUB

ARITH	LDA	ZERO
	STA	SUM	.전체 합한 값 초기화
	J	COMPARE	

COMPARE	LDX	G
	LDCH	STRLEN, X
	COMP	#3	.|100~999| -> 100같이 0이 연속으로 들어갈 경우 씹히는 것 같아서 일의 자리와 십의 자리가 0이고 백의 자리가 0이 아니라면 백의 자리 * 100 해서 넣어야할 것 같음
	JEQ	LOOP3
	COMP	#2	.|10~99|
	JEQ	LOOP2
	JLT	LOOP1	.1의 자리		.자릿수에 따라 더하여, LEN을 X에 넣을때는 -1을 해서 넣어야할 것 같다.

LOOP3	LDX	BUFF_X	.100의 자릿수까지
	LDCH	BUFFER, X
	SUB	#48
	MUL	HUNDRED
	ADD	SUM
	STA	SUM
	TIX	LEN
	LDA	ZERO
	LDCH	BUFFER, X
	SUB	#48
	MUL	TEN
	ADD	SUM
	STA	SUM
	TIX	B_LAST
	LDA	ZERO
	LDCH	BUFFER,X
	SUB	#48
	ADD	SUM
	STA	SUM
	STA	@REAR
	JSUB	QPUSH
	LDA	G
	ADD	#1
	STA	G
	J	ENDLP
LOOP2	LDX	BUFF_X	.10의 자릿수인경우
	LDCH	BUFFER, X
	SUB	#48
	MUL	TEN
	ADD	SUM
	STA	SUM
	TIX	B_LAST
	LDA	ZERO
	LDCH	BUFFER,X
	SUB	#48
	ADD	SUM
	STA	SUM
	STA	@REAR
	JSUB	QPUSH
	LDA	G
	ADD	#1
	STA	G
	J	ENDLP
LOOP1	LDX	BUFF_X	.1의 자리인 경우
	LDCH	BUFFER,X
	SUB	#48
	ADD	SUM
	STA	SUM
	STA	@REAR
	JSUB	QPUSH
	LDA	G
	ADD	#1
	STA	G
	J	ENDLP
ENDLP	LDA	CNT
	COMP	INT	.입력받기로 한 개수랑 같은지 비교
	JEQ	BFIRST	.SIGN과 SUMG의 값을 이용해 -이면 SUMG의 값을 zero sub을 해서 STR에 넣고, +인 경우 그대로 STR에 넣도록 한다.
	J	RDREC_I	.CNT까지 안 채워진 경우

QUEINIT	LDA	#QUEUE
	STA	REAR
	STA	FRONT
	RSUB
QPUSH	LDA	REAR
	ADD	#3
	STA	REAR
	RSUB
QPOP	LDA	FRONT
	ADD	#3
	STA	FRONT
	RSUB
STKINIT	LDA	#STACK
	ADD	#18
	STA	TOP
	RSUB
PUSH	LDA	TOP			.carry된 것을 넣는 용
	ADD	#3
	STA	TOP
	RSUB
POP	LDA	TOP	.POP할 때 맨 위의 값 제거해주는 것도 해줘야함
	SUB	#3
	STA	TOP
	RSUB
CARRY	STA	BB_IN	.BB=1
	J	BSTART
BFIRST	LDA	FRONT
	STA	QFRONT	.Q의 FRONT위치를 미리 저장
	JSUB	STKINIT
	LDA	ZERO
	STA	BITLEN
	STA	CNT
BREADY	LDA	QFRONT	.QFRONT의 값을 처음으로 만들어둠
	STA	FRONT
	LDA	#1
	STA	@TOP
	JSUB	PUSH
	LDA	ZERO
	STA	BITLEN
	STA	SUM
	LDA	ZERO
	LDCH	#43
	STCH	F_SIGN
	STX	TMP
	LDX	ZERO

BREADY2	LDA	ZERO
	STA	TMP
	STA	BB_IN

IN	LDA	ZERO
	+JSUB	POP
	LDA	@TOP	.STACK에 1이 들어가있다면
	COMP	#1
	JEQ	CARRY
	LDA	TOP
	ADD	#3
	STA	TOP
	LDA	ZERO
	STA	BB_IN	.BB=0

BSTART	LDA	ZERO	
	LDCH	BIT, X
	ADD	BB_IN	
	STA	BB_IN	.0이거나 1이거나 2일 것임.
	COMP	#1
	JLT	BITZERO	.두개를 더했을 때 0
	JEQ	BITONE	.두개를 더했을 때 1
	JGT	BITTWO	.두개를 더했을 때 2
BITZERO	LDA	ZERO
	STCH	BIT,X
	TIX	INT
	JEQ	BARITH
	JLT	BREADY2
	
BITONE	LDA	#1
	STCH	BIT,X
	TIX	INT
	JEQ	BARITH
	JLT	BREADY2
	
BITTWO	LDA	ZERO
	STCH	BIT,X
	LDA	#1
	STA	@TOP
	+JSUB	PUSH
	TIX	INT
	JEQ	BARITH
	JLT	BREADY2

BARITH	LDX	ZERO	.0부터 ~ INT까지
	+JSUB	FIND	.X의 끝까지 돔	
	LDA	BITLEN
	COMP	INT
	JEQ	WRREC	.총 숫자 수 : 4개 면 1111되야 종료 : 개수 센 것을 출력하러 감
	JLT	BREADY

FIND	LDA	ZERO
	LDCH	BIT, X
.	STA	TMP
	COMP	#1
	JEQ	FCOMP
	JLT	BZERO
FCOMP			.SUM과 입력받은 값 비교
	LDA	BITLEN
	ADD	#1
	STA	BITLEN
	LDA	@FRONT
	COMP	SUM
	JEQ	EQCP		.LDCH = SUM
	JLT	LCP		.LDCH < SUM
	JGT	GCP		.LDCH > SUM
			.부호 비교 -> 서로 다르면 0, 같으면 더하고 부호는 +|-, 
EQCP	LDA	ZERO
	LDCH	F_SIGN
	STA	TMP
	LDCH	SIGN, X
	COMP	TMP
	JEQ	EQSUM	.
	JLT	DISUM	.+ -
	JGT	DISUM	.- +
LCP	LDA	ZERO
	LDCH	F_SIGN
	STA 	TMP
	LDCH	SIGN, X
	COMP	TMP
	JEQ	EQSUM
	JLT	ANSUM	.-<+
	JGT	ANSUM	.+<-
GCP	LDA	ZERO
	LDCH	F_SIGN
	STA	TMP
	LDCH	SIGN, X
	COMP	TMP
	JEQ	EQSUM
	JLT	NASUM	.->+
	JGT	NASUM	.+>-

ANSUM	LDA	@FRONT
	STA	TMP
	LDA	SUM
	SUB	TMP
	STA	SUM
	J	BZERO
NASUM	LDA	@FRONT
	SUB	SUM
	STA	SUM
	LDA	ZERO
	LDCH	SIGN, X
	STCH	F_SIGN
	J	BZERO
EQSUM	LDA	@FRONT
	ADD	SUM
	STA	SUM
	LDA	ZERO
	LDCH	F_SIGN
	COMP	#44		.+인지 -인지 찾기
	JLT	PLSUM
	JGT	MISUM
PLSUM	LDA	ZERO
	LDCH	#43	.부호만 변경
	STCH	F_SIGN
	J	BZERO
MISUM	LDA	ZERO
	LDCH	#45	.부호만 변경
	STCH	F_SIGN
	J	BZERO
DISUM	LDA	ZERO	.0
	STA	SUM
	LDA	ZERO
	LDCH	#43
	STCH	F_SIGN
	J	BZERO

BZERO	LDA	FRONT
	ADD	#3
	STA	FRONT
	TIX	INT
	JLT	FIND
	JEQ	BCOMP
	RSUB	
BCOMP	LDA	SUM
	COMP	RESULT
	JEQ	PERFECT
	RSUB		.입력받은 값과 다르면 RSUB
PERFECT	LDA	F_SIGN
	COMP	R_SIGN
	JEQ	CORRECT
	RSUB
CORRECT	LDA	CNT	.입력받은 값이 맞으면 CNT
	ADD	#1
	STA	CNT
	RSUB

WRREC	LDA	ZERO
WRLOOP	TD	OUTPUT
	JEQ	WRLOOP
	LDA	CNT
	ADD	#48
	WD	OUTPUT
	J	FIN	.종료
WBCOMP	LDA	SUM
	COMP	RESULT
	JEQ	WPER
	RSUB		.입력받은 값과 다르면 RSUB
WPER	LDA	ZERO
	LDCH	F_SIGN
	COMP	SIGN
	JEQ	WCO
	RSUB
WCO	LDA	CNT	.입력받은 값이 맞으면 CNT
	ADD	#1
	STA	CNT
	RSUB
FIN	J	FIN
CLEAN	LDA	ZERO		.버퍼 비워주기	
	LDX	ZERO
CLEANLP	STCH	BUFFER, X
	TIX	#5
	JLT	CLEANLP
	RSUB
TOP	RESW	1
STACK	RESW	30	
F_SIGN	BYTE	43	.+
BITLEN	WORD	0	.I라는 자리에 해당하는 수를 넣어둘 곳
HUNDRED	WORD	100
TEN	WORD	10
SUM	WORD	0
G	WORD	0
BIT	RESB	6
BB_IN	WORD	0
TMP	BYTE	0
LEN	WORD	0	.문자열 길이
INPUT	BYTE	0
OUTPUT	BYTE	1
BUFFER	RESB	6
BUFF_X	WORD	0	.BUFFER의 X위치
B_LAST	WORD	0	.BUFFER의 X의 맨 마지막 위치+1
SIGN	RESB	6	.부호 저장
STRLEN	RESB	6
CNT	WORD	0
ZERO	WORD	0
ASEN	WORD	10
SPACE	WORD	32
INT	WORD	0	.숫자가 몇개 입력될지
RESULT	WORD	0	.찾는 결과값
QUEUE	RESW	30	.큐
FRONT	RESW	1	.FIRST	
REAR	RESW	1	.REAR
QLEN	WORD	0	.index of queue rear
QFRONT	WORD	0	.index of queue front
R_LAST	WORD	0
R_X	WORD	0
R_LEN	WORD	0
R_SIGN	BYTE	0
